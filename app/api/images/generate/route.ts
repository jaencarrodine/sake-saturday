import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

type ImageType = "bottle_art" | "group_transform";

const GEMINI_API_ENDPOINT =
  "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent";

const PROMPTS = {
  bottle_art: `Transform this sake bottle into a stunning ukiyo-e style artwork. 
    Create a dramatic, painterly Japanese aesthetic with rich colors and traditional Japanese art elements.
    The bottle should be the central focus, rendered in a classical ukiyo-e woodblock print style with:
    - Bold outlines and flat color planes characteristic of ukiyo-e
    - Traditional Japanese decorative patterns and motifs
    - Atmospheric elements like mist, waves, or cherry blossoms
    - Dramatic lighting and composition
    - Keep the bottle recognizable but artistic and stylized
    - Background should evoke traditional Japanese scenes or abstract patterns`,

  group_transform: `Transform this group photo into an imaginative Japanese-themed scene.
    Reimagine the people in one of these settings (choose one randomly):
    - Samurai era: Transform them into samurai, geisha, or merchants in Edo period Japan
    - Feudal Japan: Traditional kimono-clad figures in a historic Japanese setting
    - Cyberpunk Tokyo: Futuristic neon-lit Tokyo with traditional Japanese elements
    - Zen temple: Peaceful temple setting with traditional robes and serene atmosphere
    - Cherry blossom viewing: Traditional hanami party under blooming sakura trees
    - Sake brewery: Historical sake brewing setting with traditional workers
    
    Maintain the positions and poses of the original people but completely transform:
    - Their clothing and appearance to match the chosen setting
    - The background and environment to be immersive and detailed
    - Add atmospheric details, lighting, and cultural authenticity
    - Keep it photorealistic but clearly transformed into the Japanese theme`,
};

export async function POST(request: Request) {
  try {
    const { imageUrl, type, tastingId } = await request.json();

    if (!imageUrl || !type || !tastingId) {
      return NextResponse.json(
        { error: "Missing required fields: imageUrl, type, or tastingId" },
        { status: 400 }
      );
    }

    const apiKey = process.env.GOOGLE_API_KEY;
    if (!apiKey) {
      return NextResponse.json(
        { error: "GOOGLE_API_KEY not configured" },
        { status: 500 }
      );
    }

    const imageType = type as ImageType;
    const prompt = PROMPTS[imageType];

    if (!prompt) {
      return NextResponse.json(
        { error: "Invalid image type. Must be bottle_art or group_transform" },
        { status: 400 }
      );
    }

    let imageData: string;
    if (imageUrl.startsWith("data:")) {
      imageData = imageUrl.split(",")[1];
    } else {
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      const buffer = await blob.arrayBuffer();
      imageData = Buffer.from(buffer).toString("base64");
    }

    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt,
            },
            {
              inline_data: {
                mime_type: "image/jpeg",
                data: imageData,
              },
            },
          ],
        },
      ],
      generationConfig: {
        responseModalities: ["TEXT", "IMAGE"],
        temperature: 1.0,
        topP: 0.95,
        topK: 40,
      },
    };

    const geminiResponse = await fetch(`${GEMINI_API_ENDPOINT}?key=${apiKey}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error("Gemini API error:", errorText);
      return NextResponse.json(
        { error: "Failed to generate image from Gemini API" },
        { status: geminiResponse.status }
      );
    }

    const geminiData = await geminiResponse.json();

    let generatedImageData: string | null = null;
    if (
      geminiData.candidates &&
      geminiData.candidates[0]?.content?.parts
    ) {
      for (const part of geminiData.candidates[0].content.parts) {
        if (part.inline_data?.data) {
          generatedImageData = part.inline_data.data;
          break;
        }
      }
    }

    if (!generatedImageData) {
      console.error("No image data in Gemini response:", geminiData);
      return NextResponse.json(
        { error: "No image generated by Gemini" },
        { status: 500 }
      );
    }

    const base64Image = `data:image/jpeg;base64,${generatedImageData}`;

    const supabase = await createClient();
    const timestamp = Date.now();
    const randomStr = Math.random().toString(36).substring(2, 15);
    const fileName = `${imageType}-${timestamp}-${randomStr}.jpg`;

    const blob = await fetch(base64Image).then((r) => r.blob());
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("tasting-images")
      .upload(fileName, blob, {
        contentType: "image/jpeg",
        cacheControl: "3600",
      });

    if (uploadError || !uploadData) {
      console.error("Storage upload error:", uploadError);
      return NextResponse.json(
        { generatedImageUrl: base64Image, warning: "Could not upload to storage, returning base64" }
      );
    }

    const {
      data: { publicUrl },
    } = supabase.storage.from("tasting-images").getPublicUrl(uploadData.path);

    const { data: imageRecord, error: dbError } = await supabase
      .from("tasting_images")
      .insert({
        tasting_id: tastingId,
        original_image_url: imageUrl.startsWith("data:") ? null : imageUrl,
        generated_image_url: publicUrl,
        image_type: imageType,
        prompt_used: prompt,
      })
      .select()
      .single();

    if (dbError) {
      console.error("Database insert error:", dbError);
      return NextResponse.json(
        { generatedImageUrl: publicUrl, warning: "Image generated but not saved to database" }
      );
    }

    return NextResponse.json({
      generatedImageUrl: publicUrl,
      imageRecord,
    });
  } catch (error) {
    console.error("Error in image generation:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
}
